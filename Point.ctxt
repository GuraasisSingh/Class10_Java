#BlueJ class context
comment0.target=Point
comment0.text=\r\n\r\nIn\ Java,\ String\ is\ basically\ an\ object\ that\ represents\ sequence\ of\ char\ values.\ For\ Strings\ we\ can\ use\r\nin\ built\ java\ classes\ -\ String,\ StringBuilder,\ StringBuffer.\ We\ only\ have\ String\ in\ our\ syllabus,\ so\ we\ will\ do\ that\ only.\r\nHow\ can\ we\ create\ String\ objects?\r\n1.\ By\ using\ a\ String\ literal\r\nString\ name\ \=\ "Hello";\r\n2.\ By\ using\ the\ new\ keyword\r\nString\ name\ \=\ new\ String("Hello");\r\nDifference\ between\ the\ two?\r\nThe\ difference\ is\ how\ memory\ is\ allocated\ to\ the\ object.\r\nWe\ have\ got\ used\ to\ creating\ objects\ using\ the\ new\ keyword.\ So\ when\ we\ write\r\nString\ name\ \=\ new\ String("Hello");\r\nJava\ creates\ a\ new\ object,\ stores\ "Hello"\ in\ it\ and\ passes\ the\ address\ of\ this\ object\ to\ the\ reference\ name.\ Simple.\r\nCreation\ of\ the\ String\ object\ using\ String\ literal\ is\ more\ commonly\ used.\r\nLet\ us\ see\ what\ happens\ when\ we\ write\ the\ statement\:\r\nString\ name\ \=\ "Hello";\r\nJava\ actually\ create\ a\ pool\ of\ String\ objects\ in\ memory\ -\ called\ String\ pool\ or\ String\ literal\ pool.\r\nWhen\ you\ start\ a\ program,\ the\ pool\ is\ empty.\ When\ you\ create\ the\ first\ String\ (name)\ above,\ JVM\ (Java\ Virtual\ Machine)\ looks\ into\ the\ pool\ to\ check\ if\ "Hello"\ exists\ in\ the\ pool.\ It\ does\ not\ exist.\ So\ JVM\ creates\ one\ object\ "Hello"\ in\ the\ pool\ and\ passes\ its\ address\ to\ name\ (reference).\r\nSuppose\ I\ write\ another\ line\ in\ my\ program\r\nString\ yourName\ \=\ "Hello";\r\nJVM\ will\ again\ look\ inside\ the\ pool.\ It\ finds\ "Hello"\ there.\ It\ simply\ passes\ the\ address\ of\ "Hello"\ to\ yourName.\r\nLet\ me\ create\ another\ statement\r\nString\ greeting\ \=\ "Hello";\r\nSame\ thing\ happens.\ No\ new\ object\ is\ created.\ The\ address\ of\ "Hello"\ is\ passed\ to\ greeting\ also.\r\nWe\ can\ now\ see\ that\ all\ the\ 3\ String\ references\ -\ name,\ yourName\ and\ greeting\ -\ are\ having\ the\r\naddress\ of\ the\ same\ object.\ If\ you\ display\ any\ of\ them,\ "Hello"\ will\ be\ displayed.\r\nWhat\ is\ the\ benefit\ of\ this\ kind\ of\ allocation?\ It\ has\ been\ observed\ that\ Strings\ occupy\ quite\ a\ lot\ of\ memory.\ If\ in\ the\ above\ example,\ JVM\ had\ been\ creting\ different\ objects\ for\ the\ 3\ Hellos,\ we\ would\ have\ been\ using\ up\ 3\ times\ more\ memory.\r\nString\ name\ \=\ "Hello";\ //\ First\ object\ created.\ Address\ goes\ to\ name\r\nString\ yourName\ \=\ "Hello";\ //\ No\ object\ created.\ Address\ of\ the\ first\ passed\r\nString\ greeting\ \=\ "Hello";\ //\ No\ object\ created.\ Address\ of\ the\ first\ passed\r\nyourName\ \=\ "Goodbye";\r\nWhat\ happens\ now?\ As\ the\ pool\ does\ not\ have\ "Goodbye",\ a\ new\ object\ is\ created\ with\ "Goodbye"\ and\ address\ passed\ to\ yourName.\r\nyourName\ was\ earlier\ pointing\ to\ "Hello",\ and\ is\ now\ pointing\ to\ "Goodbye".\r\nThe\ value\ of\ yourName\ has\ NOT\ changed.\ It\ has\ simply\ switched\ to\ another\ object.\ This\ property\ of\ Strings\ is\ called\ immutability\ (unchangeable).\ We\ say\ that\ Strings\ are\ immutable.\r\nExample\:\ String\ a;\r\na\ \=\ "Apple";\ a\ \=\ "Mango";\ a\ \=\ "Grapes";\r\nIt\ appears\ that\ the\ value\ of\ a\ is\ changing\ from\ Apple\ to\ Mango\ to\ Grapes.\ Practically\ it\ shows\ the\r\nchanged\ values\ also.\ But\ internally,\ a\ was\ first\ pointing\ to\ an\ object\ "Apple",\ then\ the\ address\r\nchanged\ to\ that\ of\ "Mango".\ "Apple"\ did\ not\ change\ to\ "Mango".\ The\ reference\ of\ a\ changed\ from\ "Apple"\ to\ "Mango".\r\nI\ will\ explain\ this\ in\ the\ class\ tomorrow.\ Do\ not\ worry.\r\nWe\ will\ be\ using\ a\ set\ of\ methods\ (all\ String\ class\ methods).\ The\ list\ of\ methods\ is\ given\ below\:\r\nString\ trim\ ()\r\nString\ toLowerCase()\r\nString\ toUpperCase()\r\nint\ length(\ )\r\nchar\ charAt\ (int\ n)\r\nint\ indexOf(char\ ch)\r\nint\ lastIndexOf(char\ ch)\r\nString\ concat(String\ str)\r\nboolean\ equals\ (String\ str)\r\nboolean\ equalsIgnoreCase(String\ str)\r\nint\ compareTo(String\ str)\r\nint\ compareToIgnoreCase(String\ str)\r\nString\ replace\ (char\ oldChar,char\ newChar)\r\nString\ substring\ (int\ beginIndex)\r\nString\ substring\ (int\ beginIndex,\ int\ endIndex)\r\nboolean\ startsWith(String\ str)\ boolean\ endsWith(String\ str)\r\nString\ valueOf(all\ numeric\ types)\r\nHere\ is\ something\ we\ will\ try\ out\ tomorrow\:\r\nDisplaying\ the\ address\ of\ an\ object.\r\nDemo\ a\ \=\ new\ Demo(100);\r\nSystem.out.println(a);\ //\ will\ display\ Demo@abc7845\r\n//\ This\ means\ a\ is\ an\ object\ of\ Demo\ class\ and\ is\ located\ at\ address\r\n//\ abc7845\r\nString\ s\ \=\ new\ String("one");\r\nSystem.out.println(s);\ //\ will\ display\ one\r\nSystem.out.println(System.identityHashCode(s));\r\n//\ will\ display\ 1ae66\r\n//\ means\ s\ is\ stored\ on\ memory\ location\ 1ae66\r\n\r\nString\r\n\r\n""\ ->\ factual\ information\ Facts\r\n"hot"\r\n"cold"\r\n"Rajinder"\r\n"Chandigarh"\r\n"9814098140"\r\n9814098140\r\nNon-numeric\r\n\r\nString\ is\ an\ in-built\ class\ in\ Java\r\nStringBuilder,\ StringBuffer\ \ \ \ \ \ \ \ xxxx\r\n\r\nA.\r\nString\ a\ \=\ new\ String("Hello");\r\na\ ->\ reference\r\nnew\ String("Hello");\ ->\ object\r\nB.\r\nString\ b\ \=\ "Hello";\r\n\r\nJava\ uses\ a\ pool\ of\ Strings.\r\n\r\nString\ a\ \=\ "Java";\r\nString\ b\ \=\ "Java";\r\n\r\nMethods\ to\ perform\ operations\ on\ Strings\r\n\r\ndouble\ d\ \=\ Math.pow(10,2);\r\nClass\ Math\r\ndouble\ pow(double,\ double);\ ->\ power\ of\ a\ to\ b\r\ndouble\ ceil(double);\ ->\ higher\ int\ value\ than\ the\ arg\ passed\r\n\r\nClass\ String\r\nint\ length()\ ->\ the\ length\ of\ the\ string\r\n\r\nString\ s\ \=\ "Chandigarh";\r\nint\ l\ \=\ s.length();\r\nSOP(l);\ \ \ \ \ ->\ 10\r\ns\ \=\ "Mohali";\r\nl\ \=\ s.length();\r\nSOP(l);\ ->\ 6\r\nl\ \=\ "Panchkula".length();\r\nSOP(l);\ ->\ 9\r\n\r\nOrphans\ XXXX\r\n\r\n
comment1.params=
comment1.target=Point()
comment2.params=m
comment2.target=Point(int)
comment3.params=m\ n
comment3.target=Point(int,\ int)
comment4.params=
comment4.target=void\ show()
comment5.params=m
comment5.target=void\ set(int)
comment6.params=m\ n
comment6.target=void\ set(int,\ int)
comment7.params=
comment7.target=void\ main()
numComments=8
